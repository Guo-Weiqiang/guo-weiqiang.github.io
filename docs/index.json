[{"categories":["data structure and algorithms"],"content":"Huffman编码 霍夫曼编码（英语：Huffman Coding），又译为哈夫曼编码、赫夫曼编码，是一种用于无损数据压缩的熵编码（权编码）算法。由美国计算机科学家大卫·霍夫曼（David Albert Huffman）在1952年发明，是一种变长的编码方式，对出现频率高的字符采用较短的编码，而对出现频率较低的字符采用较长的编码（在对字符进行变长编码时，注意要满足前缀码规则：任意字符的编码不能是其他字符编码的前缀） 要得到Huffman编码，首先需要构建Huffman树。我们首先来介绍一下Huffman树 Huffman树 在我们构造Huffman树之前，我们需要声明几个定义： 路径：连接两个结点的分支，构成这两个结点的路径 路径长度：路径的分支数 结点的权：为结点赋予的一个有意义的实数 结点的带权路径长度：根结点到该节点的 路径长度 乘以 该结点 的权值，及该结点的带权路径长度 树的带权路径长度：树中 所有叶子结点的带权路径长度 之和 Huffman树：$n$个带权叶子 构成的二叉树中，带权路径WPL最小的二叉树称为 Huffman树 Huffman树的构造步骤 根据给定的$n$个权值$w_1,w_2,w_3,…,w_n$，构成 含$n$个二叉树 的森林$F={T_1,T_2,…,T_n}$，其中每个二叉树仅含一个权值为$w_i$的根结点，且无左右子树（即构成n个只有一个结点的二叉树） 从森林中选取两个权值最小的 二叉树作为新树的左右子树列来构成一个新树（注意，权值相对较小的为左子树），新树的根结点权值即左右子树权值之和 从森林$F$中删除构建新树的两棵子树，同时将新树加入到森林$F$中 重复步骤2、3，直到森林$F$中只有一棵树，即得到Huffman树 举个栗子： 给定权集：{2,3,4,7,8,9}，构造一棵Huffman树： 构造过程如上所示。 Huffman编码的应用 我们介绍了Huffman树是如何来构造的，那么Huffman编码是如何应用到实际工作中的呢？ 我们给定一个字符串，统计每个字符出现的频数，作为我们的权集，来构造一棵Huffman树，再通过我们构造的Huffman树来得到每个字符的编码，进而得到字符串的编码。 举个栗子，我们给定字符串\"state,seat,act,tea,cat,set,a,eat\" 通过Huffman树得到Huffman编码： a:00 ,:01 t:10 e:110 c:1110 s:1111 (整个字符串的编码)1111100010110011111110001001001110100110110000111100010011111110100100011100010 Huffman编码 那么接下来我们来一探究竟，看看我们是如何通过一棵Huffman树来得到每个叶子结点的Huffman编码呢？ 我们需要对我们构造的Huffman树做一个小小的操作：在所有的左分支上标$0$，所有的右分支上标$1$。（即在每个结点到左孩子的边上写上数字$0$，到右孩子的边上写上数字$1$） 对于上面Huffman树，我们就得到： 通过这样的处理我们就能得到每个字符的编码了。 每个字符的编码即 根结点到与该字符对应的叶子结点 的路径上所有编码的连接体 对于上图中权值为$2$的叶子结点，其编码就为 $0100$ Huffman编码的C#代码实现 介绍完了Huffman编码的基本原理，我们来给出他的代码实现: 首先给出二叉树树结点的实现代码： /// \u003csummary\u003e /// 定义二叉树结点 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e二叉树结点数据域的数据类型\u003c/typeparam\u003e public class BinTreeNode\u003cT\u003e : IComparable\u003cBinTreeNode\u003cT\u003e\u003e where T : IComparable\u003cT\u003e { /// \u003csummary\u003e /// 结点数据域所含数据 /// \u003c/summary\u003e private T _data; /// \u003csummary\u003e /// 获取或设置结点数据 /// \u003c/summary\u003e public T Data { get { return _data; } set { if (value == null) throw new ArgumentNullException(); _data = value; } } /// \u003csummary\u003e /// 获取或设置结点的左子树 /// \u003c/summary\u003e public BinTreeNode\u003cT\u003e LeftChild { get; set; } /// \u003csummary\u003e /// 获取或设置结点的右子树 /// \u003c/summary\u003e public BinTreeNode\u003cT\u003e RightChild { get; set; } /// \u003csummary\u003e /// 构造函数，初始化结点 /// \u003c/summary\u003e /// \u003cparam name=\"data\"\u003e初始化结点的数据\u003c/param\u003e public BinTreeNode(T data) { LeftChild = null; _data = data; RightChild = null; } /// \u003csummary\u003e /// 构造函数，初始化结点 /// \u003c/summary\u003e /// \u003cparam name=\"lChild\"\u003e初始化结点的左子树\u003c/param\u003e /// \u003cparam name=\"data\"\u003e初始化结点的数据\u003c/param\u003e /// \u003cparam name=\"rChild\"\u003e初始化结点的右子树\u003c/param\u003e public BinTreeNode(BinTreeNode\u003cT\u003e lChild, T data, BinTreeNode\u003cT\u003e rChild) { LeftChild = lChild; _data = data; RightChild = rChild; } public int CompareTo(BinTreeNode\u003cT\u003e other) { if (other == null) throw new ArgumentNullException(); return _data.CompareTo(other.Data); } } 接着给出Huffman树结点的实现代码（与二叉树结点相比，每个结点多了一个权重Weight属性） /// \u003csummary\u003e /// Huffman树结点定义(base()向父类构造函数 传递参数) /// \u003c/summary\u003e public class HuffManTreeNode : BinTreeNode\u003cchar\u003e //继承了二叉树结点 { /// \u003csummary\u003e /// Huffman树结点的权重 /// \u003c/summary\u003e public int Weight { get; set; } /// \u003csummary\u003e /// 构造Huffman树结点 /// \u003c/summary\u003e /// \u003cparam name=\"data\"\u003e\u003c/param\u003e /// \u003cparam name=\"weight\"\u003e\u003c/param\u003e public HuffManTreeNode(char data, int weight) : base(data) { Weight = weight; } /// \u003csummary\u003e /// 构造 Huffman树结点 所含数据为空 /// \u003c/summary\u003e /// \u003cparam name=\"weight\"\u003e\u003c/param\u003e public HuffManTreeNode(int weight) : base('\\0') { Weight = weight; } } 接着给出Huffman编码字典的实现代码，用以存储字符及字符对应的Huffman编码 /// \u003csummary\u003e /// 构造一个数据类型，存储字符及字符的huffman编码 /// \u003c/summary\u003e public class HuffmanDicItem { /// \u003csummary\u003e /// 字符 /// \u003c/summary\u003e public char Character { get; set; } /// \u003csummary\u003e /// 字符的huffman编码 /// \u003c/summary\u003e public string Code { get; set; } public HuffmanDicItem(char character, string code) { if (character == '\\0') throw new Exception(\"字符为空\"); if (code == string.Empty) throw new Exception(\"编码为空\"); Character = character; Code = code; } } 最后给出Huffman树的的实现代码（实现Huffman树的构造、Huffman编码、对Huffman编码进行解码） public class HuffManTree { /// \u003csummary\u003e /// 对字符串中的字符进行频数统计，构造森林 /// \u003c/summary\u003e /// \u003cparam name=\"str\"\u003e待编码的字符串\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e private List\u003cHuffManTreeNode\u003e CreateInitForest(string str) { if","date":"2022-08-25","objectID":"/huffman%E7%BC%96%E7%A0%81/:0:1","tags":["algorithms","c#"],"title":"Huffman编码","uri":"/huffman%E7%BC%96%E7%A0%81/"},{"categories":["data structure and algorithms"],"content":"KMP算法 我们知道，串类型有一个功能是查找子串，而查找的方法有多种，如暴力查找法、KMP算法，这次我们来介绍一下这些方法 首先说明一下一些符号及名词的含义： S为主串 T为待查找的子串，也称为模式串 子串在主串中的位置： 子串在主串中第一次出现时首字母在主串中的索引位置，即子串在主串中的位置。对于主串“to be or not to be ,This is a question”，子串“be”在子串中的位置为3 查找子串，即从主串中查找子串是否存在，如果存在返回子串在主串中的位置 字符串的前缀：对于字符串A和B，若有A=BS，B、S为任意非空字符串，则称B为A的前缀。如字符串“Pig”，其前缀包括{“P”, “Pi”} 字符串的后缀： 对于字符串A和B，若有A=SB，B、S为任意非空字符串，则称B为A的后缀，如字符串“Pig”，其后缀包括{“g”, “ig”} i、j 分别代表当前匹配到的主串位置和子串位置 此外，在本文中，数组的索引一律从0开始 暴力查找 暴力查找的步骤为： if (S[i] == P[j]) { i++;j++ } else { i = i - j + 1; j = 0; } 其文字表述为： 从主串的首字符开始，与子串的每个字符 逐一进行比较 若遇到不匹配的字符，则将当前首字符的下一个字符作为首字符 重复步骤1，步骤2，直到寻找到子串或者扫描完整个主串(其中，i、j表示主串和子串当前比较的位置) 举个栗子：如下图，我们要寻找“ABCE”在“ABCABCDHIJK”中的位置 S[0] == P[0], 执行i++;j++ ，比较S[1]与P[1] S[1] == P[1], 执行i++;j++ ，比较S[2]与P[2] S[2] == P[2], 执行i++;j++ ，比较S[3]与P[3] S[3] != P[3], 执行 i = i - j + 1;j=0; 得到i=1, j=0，重新开始比较; S[1] != P[0],执行 i = i - j + 1;j=0; 得到i=2, j=0，重新开始比较; S[2] != P[0],执行 i = i - j + 1;j=0; 得到i=3, j=0，重新开始比较; S[3] == P[0],执行i++,j++;得到i=4，j=1，继续比较 S[4] == P[1],执行i++,j++;得到i=5，j=2，继续比较 S[5] == P[2],执行i++,j++;得到i=6，j=3，继续比较 依次比较，得到结果………….. 我们不难看出上述的比较方式中存在着一些不必要的步骤： 当比较到第4步时主串和子串的前三位是匹配的（即S[0] == P[0], S[1]==P[1],S[2]==P[2]），也就是说我们可以由模式串的前三位字符确定主串的前三位字符，很明显前三位字符分别为A、B、C。我们也很容易可以看出P[0] != P[1], P[0]!=P[2],所以有S[1] != P[0], S[2]!=P[0]. 也就是说比较到第4步时，我们就知道了S[1] != P[0], S[2]!=P[0]，而按照暴力查找的步骤， 它会会依次比较S[1]和P[0], S[2]和P[0]，也就是说暴力查找进行了不必要的指针回溯（这里的指针即上文中的i与j），这很明显是多余的操作。 面对暴力查找这种机械又存在明显缺点的字符串查找算法，一般人可以忍，但D.E.Knuth，J.H.Morris和V.R.Pratt这三位大佬忍不了，他们提出了一种新算法，可以避免暴力查找算法中会出现的不必要的指针回溯问题，提高查找效率。这个算法就是我们接下来要介绍的KMP算法。 KMP算法 KMP算法的步骤是： if (j == -1 || S[i] == P[j]) { i++; j++; } else { j = next[j]; } 用文字来表述即：如果j==-1或者S[i]与S[j]匹配成功，那么执行i++,j++,匹配主串和子串的下一位。 如果S[i]与S[j] 匹配失败，i指针不变，j指针回溯到next[j]处。 这里的next[]是一个整型数组，也是KMP算法的核心 接下里我们就来说说next数组是什么及为什么上述的步骤可以避免暴力查找中不必要的指针回溯问题。 寻找前缀后缀公共元素的最长长度 我们首先来寻找一下模式串的前缀后缀公共元素的最长长度 给定一个模式串“ABCDABD”，其子串的前缀、后缀、前后缀最大公共元素长度如下表： 在说道next数组之前，我们先说一下另一个概念，部分匹配表。 部分匹配表 同样是对于模式串“ABCDABD”，其部分匹配表如下： 将部分匹配表看作一个数组a的话，其每一个位置上的值 就是模式串中 从字符串开头到该位置 的 子串其前后缀最大公共元素的长度。 例：a[2]位置的值即 模式串的子串“ABC”其前后缀最大公共长度值。“ABC”的前缀为{“A”,“AB”},“ABC”的后缀为{“C”,“BC”},其最大公共长度值为0，所以a[2] = 0; next数组 那么我们的next数组究竟是什么呢？ 如果我们把模式串“ABCDABD”的部分匹配表整体右移一位，并将首元素设为-1，就得到了我们的next数组。 那么next数组每一位的值分别代表什么呢？ next[i] 的值 表示 P[0]-P[i-1]这个子串其 前缀后缀最大公共元素的长度。对于next[0]，由于它之前没有字符，将其值设为-1 再举个栗子：next[4]的值就是 模式串的子串“ABCD” 前后缀最大公共元素的长度 next[4] = 0 知道了next数组的具体含义，接下来我们就来看看KMP算法具体是如何执行的，以及为什么将j回溯到next[j]就可以避免暴力查找算法中不必要的指针回溯问题 我们来举个栗子： 给定主串“BBC ABCDAB ABCDABCDABDE”，模式串“ABCDABD”，寻找模式串在主串中的位置 模式串的next数组如下图： 匹配过程如下： i=0,j=0,S[0] != P[0],执行j=next[0],得到i=0,j=-1 i=0,j=-1,满足j==-1，执行i++,j++;得到i =1, j=0; i=1,j=0, S[1]!=P[0],执行j=next[0],得到j=-1; i=1,j=-1,满足j==-1，执行i++,j++;得到i =2, j=0; i=2,j=0,S[2]!=P[0]，执行j=next[0],得到i=2，j=-1； 重复以上步骤，直到下图位置 此时匹配成功,i=4, j=0, S[4]==P[0],执行i++，j++;得到i=5,j=1;继续匹配至下图位置 此时i=10，j=6，S[10]!=P[6],执行j=next[6],而next[6]=2,所以j指针回溯到2，得到i=10,j=2;从直观上来看，next[6]即模式串的子串“ABCDAB”的前后缀公共元素最大长度 换个角度来看，next[6]即主串中“ ”前的子串“ABCDAB”的后缀与模式串子串“ABCDABD”的前缀 的公共元素最大长度，在这里为2，又由于数组、字符串的索引从0开始，那么2的位置恰好对应 公共元素的下一位，这样我们就避免了i、j指针不必要的回溯，利用已知的匹配信息，将j回溯到合理的位置 以上就是KMP算法的过程。 我们还遗漏了一个问题，如何求出next数组呢？代码如下 public int[] Get_Next(IString s) { int i = 0; int j = -1; int[] next = new int[256]; next[0] = -1; int patternLength = s.Length; while (i \u003c patternLength) { if (j == -1 || s[i] == s[j]) // s[i]表示后缀字符 // s[j]表示前缀字符 { ++i; ++j; next[i] = j; // next[i]之前模式串的前缀后缀最大匹配长度j } else { j = next[j]; // 不匹配，则j回溯 //模式字符串以kmp算法的思路 与自身匹配 } } return next; } 我们可以看到，获取next数组的代码和KMP算法查找的代码其实是很相似的。 我们可以理解为：将模式串P作为主串，将模式串P又作为模式串，以KMP算法的思路保持i不变对j进行回溯。很有意思的是，在KMP算法中我们利用next数组来回溯j，而在求next数组的过程，我们也利用next数组本身来回溯j。 我们来举个栗子，看看这段代码究竟是怎样工作的。 对于模式串P“ABAB”,其前缀集合为{A、AB、ABA},后缀集合为{B、AB、BAB}，交集为AB i=0,j=-1,满足j=-1,执行i++，j++,next[i]=j;得到i=1,j=0,next[1]=0; i=1,j=0，比较P[1]与P[0],P[1]!=P[0],执行j=next[j]，j=next[0]=-1,得到i=1,j=-1; i=1,j=-1;满足j=-1,执行i++，j++,next[i]=j;得到i=2,j=0,next[2]=0; i=2,j=0，比较P[2]与P[0],P[2]==P[0],执行i++,j++,next[i]=j,得到i=3,j=1，next[3]=1; 这样我们就得到了模式串“ABAB”的next数组，其元素集合为{-1,0,0,1} 我们也可以从前缀后缀的角度来求next数组 以上基本上算是介绍完了KMP算法，相对于暴力查找算法给出了一种更高效的字符串查找算法。","date":"2022-08-25","objectID":"/kmp%E7%AE%97%E6%B3%95/:0:1","tags":["algorithms"],"title":"KMP算法","uri":"/kmp%E7%AE%97%E6%B3%95/"}]